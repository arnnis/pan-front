{"version":3,"sources":["../src/constants/poolType.ts","../src/constants/gasCost.ts","../src/constants/math.ts","../src/transformer.ts","../src/createV3Pool.ts","../src/utils/isV3Pool.ts"],"names":["Percent"],"mappings":"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","sourcesContent":["export const V3_POOL_TYPE = 'V3' as const\n","import { ChainId } from '@pancakeswap/chains'\n\n// Cost for crossing an uninitialized tick.\nexport const COST_PER_UNINIT_TICK = 0n\n\nexport const BASE_SWAP_COST_V3 = (id: ChainId): bigint => {\n  switch (id) {\n    case ChainId.BSC:\n    case ChainId.BSC_TESTNET:\n    case ChainId.ETHEREUM:\n    case ChainId.GOERLI:\n    case ChainId.ZKSYNC:\n    case ChainId.ZKSYNC_TESTNET:\n    case ChainId.POLYGON_ZKEVM:\n    case ChainId.POLYGON_ZKEVM_TESTNET:\n    case ChainId.ARBITRUM_ONE:\n    case ChainId.OPBNB:\n    case ChainId.OPBNB_TESTNET:\n      return 2000n\n    default:\n      return 0n\n  }\n}\nexport const COST_PER_INIT_TICK = (id: ChainId): bigint => {\n  switch (id) {\n    case ChainId.BSC:\n    case ChainId.BSC_TESTNET:\n    case ChainId.ETHEREUM:\n    case ChainId.GOERLI:\n    case ChainId.ZKSYNC:\n    case ChainId.ZKSYNC_TESTNET:\n    case ChainId.POLYGON_ZKEVM:\n    case ChainId.POLYGON_ZKEVM_TESTNET:\n    case ChainId.ARBITRUM_ONE:\n    case ChainId.OPBNB:\n    case ChainId.OPBNB_TESTNET:\n      return 31000n\n    default:\n      return 0n\n  }\n}\n\nexport const COST_PER_HOP_V3 = (id: ChainId): bigint => {\n  switch (id) {\n    case ChainId.BSC:\n    case ChainId.BSC_TESTNET:\n    case ChainId.ETHEREUM:\n    case ChainId.GOERLI:\n    case ChainId.ZKSYNC:\n    case ChainId.ZKSYNC_TESTNET:\n    case ChainId.POLYGON_ZKEVM:\n    case ChainId.POLYGON_ZKEVM_TESTNET:\n    case ChainId.ARBITRUM_ONE:\n    case ChainId.OPBNB:\n    case ChainId.OPBNB_TESTNET:\n      return 80000n\n    default:\n      return 0n\n  }\n}\n","import { Percent } from '@pancakeswap/swap-sdk-core'\n\n// constants used internally but not expected to be used externally\nexport const NEGATIVE_ONE = BigInt(-1)\n\n// used in liquidity amount math\nexport const Q96 = 2n ** 96n\nexport const Q192 = Q96 ** 2n\n\n// used in fee calculation\nexport const MAX_FEE = 10n ** 6n\nexport const ONE_HUNDRED_PERCENT = new Percent('1')\nexport const ZERO_PERCENT = new Percent('0')\nexport const Q128 = 2n ** 128n\n","import { ChainId } from '@pancakeswap/chains'\nimport {\n  parseCurrency,\n  parseCurrencyAmount,\n  toSerializableCurrency,\n  toSerializableCurrencyAmount,\n} from '@pancakeswap/routing-sdk'\nimport { Percent } from '@pancakeswap/swap-sdk-core'\nimport { Tick } from '@pancakeswap/v3-sdk'\n\nimport { SerializableTick, SerializableV3Pool, V3Pool, V3PoolData } from './types'\nimport { createV3Pool } from './createV3Pool'\n\nconst ONE_HUNDRED = 100n\n\nexport function toSerializableTick(tick: Tick): SerializableTick {\n  return {\n    index: tick.index,\n    liquidityNet: String(tick.liquidityNet),\n    liquidityGross: String(tick.liquidityGross),\n  }\n}\n\nexport function toSerializableV3Pool(v3Pool: V3Pool): SerializableV3Pool {\n  const pool = v3Pool.getPoolData()\n  return {\n    ...pool,\n    token0: toSerializableCurrency(pool.token0),\n    token1: toSerializableCurrency(pool.token1),\n    liquidity: pool.liquidity.toString(),\n    sqrtRatioX96: pool.sqrtRatioX96.toString(),\n    token0ProtocolFee: pool.token0ProtocolFee.toFixed(0),\n    token1ProtocolFee: pool.token1ProtocolFee.toFixed(0),\n    ticks: pool.ticks?.map(toSerializableTick),\n    reserve0: pool.reserve0 && toSerializableCurrencyAmount(pool.reserve0),\n    reserve1: pool.reserve1 && toSerializableCurrencyAmount(pool.reserve1),\n  }\n}\n\nexport function parseTick(tick: SerializableTick): Tick {\n  return new Tick(tick)\n}\n\nexport function parseV3Pool(chainId: ChainId, pool: SerializableV3Pool): V3Pool {\n  const poolData: V3PoolData = {\n    ...pool,\n    token0: parseCurrency(chainId, pool.token0),\n    token1: parseCurrency(chainId, pool.token1),\n    liquidity: BigInt(pool.liquidity),\n    sqrtRatioX96: BigInt(pool.sqrtRatioX96),\n    token0ProtocolFee: new Percent(pool.token0ProtocolFee, ONE_HUNDRED),\n    token1ProtocolFee: new Percent(pool.token1ProtocolFee, ONE_HUNDRED),\n    ticks: pool.ticks?.map(parseTick),\n    reserve0: pool.reserve0 && parseCurrencyAmount(chainId, pool.reserve0),\n    reserve1: pool.reserve1 && parseCurrencyAmount(chainId, pool.reserve1),\n  }\n\n  return createV3Pool(poolData)\n}\n","import { Currency, CurrencyAmount, Price, ONE, ZERO } from '@pancakeswap/swap-sdk-core'\nimport { logCurrency } from '@pancakeswap/routing-sdk'\nimport {\n  encodeSqrtRatioX96,\n  TickList,\n  TickMath,\n  SwapMath,\n  LiquidityMath,\n  TICK_SPACINGS,\n  FeeAmount,\n} from '@pancakeswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport memoize from 'lodash/memoize.js'\n\nimport type { V3Pool, V3PoolData } from './types'\nimport { BASE_SWAP_COST_V3, COST_PER_HOP_V3, COST_PER_INIT_TICK, NEGATIVE_ONE, Q192, V3_POOL_TYPE } from './constants'\n\nexport function createV3Pool(params: V3PoolData): V3Pool {\n  let p = { ...params, type: V3_POOL_TYPE }\n  const tickSpacing = p.tickSpacing ?? TICK_SPACINGS[p.fee as FeeAmount]\n  invariant(Boolean(tickSpacing) === true, 'Invalid fee for v3 pool')\n\n  const pool: V3Pool = {\n    type: V3_POOL_TYPE,\n    swapToPrice: (price) => {\n      const sortedPrice = price.baseCurrency.wrapped.sortsBefore(price.quoteCurrency.wrapped) ? price : price.invert()\n      const sqrtRatioLimit = encodeSqrtRatioX96(sortedPrice.numerator, sortedPrice.denominator)\n      if (sqrtRatioLimit === p.sqrtRatioX96) {\n        return {\n          inputAmount: CurrencyAmount.fromRawAmount(p.token0, 0n),\n        }\n      }\n      const zeroForOne = sqrtRatioLimit < p.sqrtRatioX96\n      const outputReserve = zeroForOne ? p.reserve1 : p.reserve0\n      const outputCurrency = zeroForOne ? p.token1 : p.token0\n      const outputAmount = CurrencyAmount.fromRawAmount(outputCurrency.wrapped, outputReserve?.quotient ?? 0n)\n      const [inputAmount] = getInputAmount(outputAmount, {\n        ...p,\n        sqrtPriceLimitX96: sqrtRatioLimit,\n      })\n      return {\n        inputAmount,\n      }\n    },\n    getReserve: (c) =>\n      p.token0.wrapped.equals(c.wrapped)\n        ? p.reserve0 ?? CurrencyAmount.fromRawAmount(p.token0, 0n)\n        : p.reserve1 ?? CurrencyAmount.fromRawAmount(p.token1, 0n),\n    getCurrentPrice: (base) => {\n      return priceOf(p, base.wrapped)\n    },\n    getTradingPairs: () => [[p.token0, p.token1]],\n    getId: () => p.address,\n    update: (poolData) => {\n      p = { ...p, ...poolData }\n    },\n    log: () =>\n      `V3 ${p.token0.symbol} - ${p.token1.symbol} (${p.fee}) - ${p.address} - price ${token0Price(p).toSignificant(\n        6,\n      )} ${p.token1.symbol}/${p.token0.symbol}`,\n\n    getPoolData: () => p,\n\n    getQuote: ({ amount, isExactIn }) => {\n      const { ticks } = p\n      if (!ticks?.length) {\n        return undefined\n      }\n      try {\n        const [quote, poolAfter] = isExactIn\n          ? getOutputAmount(amount.wrapped, p)\n          : getInputAmount(amount.wrapped, { ...p, exactOut: true })\n\n        // Not enough liquidity to perform the swap\n        if (quote.quotient <= 0n) {\n          return undefined\n        }\n\n        const { tick: tickAfter } = poolAfter\n        const newPool: V3PoolData = {\n          ...p,\n          tick: tickAfter,\n          sqrtRatioX96: poolAfter.sqrtRatioX96,\n          liquidity: poolAfter.liquidity,\n        }\n        return {\n          poolAfter: createV3Pool(newPool),\n          quote,\n          pool,\n        }\n      } catch (e) {\n        // console.warn('No enough liquidity to perform swap', e)\n        return undefined\n      }\n    },\n\n    estimateGasCostForQuote: ({ poolAfter }) => {\n      const { tick, ticks, token0 } = p\n      const { chainId } = token0\n      const { tick: tickAfter } = poolAfter.getPoolData()\n      invariant(ticks !== undefined, '[Estimate gas]: No valid tick list found')\n      const numOfTicksCrossed = TickList.countInitializedTicksCrossed(ticks, tick, tickAfter)\n      const tickGasUse = COST_PER_INIT_TICK(chainId) * BigInt(numOfTicksCrossed)\n      return BASE_SWAP_COST_V3(chainId) + COST_PER_HOP_V3(chainId) + tickGasUse\n    },\n  }\n\n  return pool\n}\n\n/**\n * Returns the current mid price of the pool in terms of token0, i.e. the ratio of token1 over token0\n */\nconst token0Price = memoize(\n  ({\n    token0,\n    token1,\n    sqrtRatioX96,\n  }: Pick<V3PoolData, 'token0' | 'token1' | 'sqrtRatioX96'>): Price<Currency, Currency> => {\n    return new Price(token0, token1, Q192, sqrtRatioX96 * sqrtRatioX96)\n  },\n  ({ token0, token1, sqrtRatioX96 }) => `${logCurrency(token0)}_${logCurrency(token1)}_${sqrtRatioX96}`,\n)\n\nconst token1Price = memoize(\n  ({\n    token0,\n    token1,\n    sqrtRatioX96,\n  }: Pick<V3PoolData, 'token0' | 'token1' | 'sqrtRatioX96'>): Price<Currency, Currency> => {\n    return new Price(token1, token0, sqrtRatioX96 * sqrtRatioX96, Q192)\n  },\n  ({ token0, token1, sqrtRatioX96 }) => `${logCurrency(token0)}_${logCurrency(token1)}_${sqrtRatioX96}`,\n)\n\n/**\n * Return the price of the given token in terms of the other token in the pool.\n * @param token The token to return price of\n * @returns The price of the given token, in terms of the other.\n */\nfunction priceOf(\n  p: Pick<V3PoolData, 'token0' | 'token1' | 'sqrtRatioX96'>,\n  token: Currency,\n): Price<Currency, Currency> {\n  invariant(involvesToken(p, token), 'TOKEN')\n  return token.equals(p.token0) ? token0Price(p) : token1Price(p)\n}\n\ntype SwapBaseParams = Omit<V3PoolData, 'reserve0' | 'reserve1' | 'address'> & {\n  sqrtPriceLimitX96?: bigint\n}\n\ntype SwapParams = SwapBaseParams & {\n  zeroForOne: boolean\n  amountSpecified: bigint\n  tickSpacing: number\n}\n\ntype StepComputations = {\n  sqrtPriceStartX96: bigint\n  tickNext: number\n  initialized: boolean\n  sqrtPriceNextX96: bigint\n  amountIn: bigint\n  amountOut: bigint\n  feeAmount: bigint\n}\n\n/**\n * Returns true if the token is either token0 or token1\n * @param token The token to check\n * @returns True if token is either token0 or token\n */\nfunction involvesToken(p: Pick<V3PoolData, 'token0' | 'token1'>, token: Currency): boolean {\n  return token.equals(p.token0) || token.equals(p.token1)\n}\n\n/**\n * Given an input amount of a token, return the computed output amount, and a pool with state updated after the trade\n * @param inputAmount The input amount for which to quote the output amount\n * @param sqrtPriceLimitX96 The Q64.96 sqrt price limit\n * @returns The output amount and the pool with updated state\n */\nfunction getOutputAmount(\n  inputAmount: CurrencyAmount<Currency>,\n  { sqrtPriceLimitX96, ...pool }: SwapBaseParams,\n): [CurrencyAmount<Currency>, Omit<SwapBaseParams, 'sqrtPriceLimitX96'>] {\n  invariant(involvesToken(pool, inputAmount.currency), 'TOKEN')\n  const tickSpacing = pool.tickSpacing ?? TICK_SPACINGS[pool.fee as FeeAmount]\n  invariant(!!tickSpacing, 'Invalid tick spacing')\n\n  const zeroForOne = inputAmount.currency.equals(pool.token0)\n\n  const {\n    amountCalculated: outputAmount,\n    sqrtRatioX96,\n    liquidity,\n    tickCurrent,\n  } = swap({\n    ...pool,\n    tickSpacing,\n    amountSpecified: inputAmount.quotient,\n    zeroForOne,\n    sqrtPriceLimitX96,\n  })\n  const outputToken = zeroForOne ? pool.token1 : pool.token0\n  return [\n    CurrencyAmount.fromRawAmount(outputToken, outputAmount * NEGATIVE_ONE),\n    {\n      ...pool,\n      sqrtRatioX96,\n      liquidity,\n      tick: tickCurrent,\n    },\n  ]\n}\n\n/**\n * Given a desired output amount of a token, return the computed input amount and a pool with state updated after the trade\n * @param outputAmount the output amount for which to quote the input amount\n * @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap\n * @returns The input amount and the pool with updated state\n */\nfunction getInputAmount(\n  outputAmount: CurrencyAmount<Currency>,\n  { sqrtPriceLimitX96, exactOut, ...pool }: SwapBaseParams & { exactOut?: boolean },\n): [CurrencyAmount<Currency>, Omit<SwapBaseParams, 'sqrtPriceLimitX96'>] {\n  invariant(outputAmount.currency.isToken && involvesToken(pool, outputAmount.currency), 'TOKEN')\n  const tickSpacing = pool.tickSpacing ?? TICK_SPACINGS[pool.fee as FeeAmount]\n  invariant(!!tickSpacing, 'Invalid tick spacing')\n\n  const zeroForOne = outputAmount.currency.equals(pool.token1)\n\n  const {\n    amountSpecifiedRemaining,\n    amountCalculated: inputAmount,\n    sqrtRatioX96,\n    liquidity,\n    tickCurrent,\n  } = swap({\n    ...pool,\n    tickSpacing,\n    amountSpecified: outputAmount.quotient * NEGATIVE_ONE,\n    zeroForOne,\n    sqrtPriceLimitX96,\n  })\n\n  if (exactOut) {\n    invariant(amountSpecifiedRemaining === 0n, 'INSUFFICIENT_LIQUIDITY_EXACT_OUT')\n  }\n\n  const inputToken = zeroForOne ? pool.token0 : pool.token1\n  return [\n    CurrencyAmount.fromRawAmount(inputToken, inputAmount),\n    {\n      ...pool,\n      sqrtRatioX96,\n      liquidity,\n      tick: tickCurrent,\n    },\n  ]\n}\n\nfunction swap({\n  fee,\n  tickSpacing,\n  ticks,\n  tick: tickCurrent,\n  liquidity,\n  sqrtRatioX96,\n  zeroForOne,\n  amountSpecified,\n  sqrtPriceLimitX96,\n}: SwapParams): {\n  amountCalculated: bigint\n  sqrtRatioX96: bigint\n  liquidity: bigint\n  tickCurrent: number\n  amountSpecifiedRemaining: bigint\n} {\n  invariant(ticks !== undefined, '[Swap]: No valid tick list found')\n  // eslint-disable-next-line no-param-reassign\n  if (!sqrtPriceLimitX96) sqrtPriceLimitX96 = zeroForOne ? TickMath.MIN_SQRT_RATIO + ONE : TickMath.MAX_SQRT_RATIO - ONE\n\n  if (zeroForOne) {\n    invariant(sqrtPriceLimitX96 > TickMath.MIN_SQRT_RATIO, 'RATIO_MIN')\n    invariant(sqrtPriceLimitX96 < sqrtRatioX96, 'RATIO_CURRENT')\n  } else {\n    invariant(sqrtPriceLimitX96 < TickMath.MAX_SQRT_RATIO, 'RATIO_MAX')\n    invariant(sqrtPriceLimitX96 > sqrtRatioX96, 'RATIO_CURRENT')\n  }\n\n  const exactInput = amountSpecified >= ZERO\n\n  // keep track of swap state\n\n  const state = {\n    amountSpecifiedRemaining: amountSpecified,\n    amountCalculated: ZERO,\n    sqrtPriceX96: sqrtRatioX96,\n    tick: tickCurrent,\n    liquidity,\n  }\n\n  // start swap while loop\n  while (state.amountSpecifiedRemaining !== ZERO && state.sqrtPriceX96 !== sqrtPriceLimitX96) {\n    const step: Partial<StepComputations> = {}\n    step.sqrtPriceStartX96 = state.sqrtPriceX96\n\n    // because each iteration of the while loop rounds, we can't optimize this code (relative to the smart contract)\n    // by simply traversing to the next available tick, we instead need to exactly replicate\n    // tickBitmap.nextInitializedTickWithinOneWord\n    ;[step.tickNext, step.initialized] = TickList.nextInitializedTickWithinOneWord(\n      ticks,\n      state.tick,\n      zeroForOne,\n      tickSpacing,\n    )\n\n    if (step.tickNext < TickMath.MIN_TICK) {\n      step.tickNext = TickMath.MIN_TICK\n    } else if (step.tickNext > TickMath.MAX_TICK) {\n      step.tickNext = TickMath.MAX_TICK\n    }\n\n    step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext)\n    ;[state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount] = SwapMath.computeSwapStep(\n      state.sqrtPriceX96,\n      (zeroForOne ? step.sqrtPriceNextX96 < sqrtPriceLimitX96 : step.sqrtPriceNextX96 > sqrtPriceLimitX96)\n        ? sqrtPriceLimitX96\n        : step.sqrtPriceNextX96,\n      state.liquidity,\n      state.amountSpecifiedRemaining,\n      fee,\n    )\n\n    if (exactInput) {\n      state.amountSpecifiedRemaining -= step.amountIn! + step.feeAmount!\n      state.amountCalculated = state.amountCalculated! - step.amountOut!\n    } else {\n      state.amountSpecifiedRemaining = state.amountSpecifiedRemaining! + step.amountOut!\n      state.amountCalculated = state.amountCalculated! + (step.amountIn! + step.feeAmount!)\n    }\n\n    // TODO\n    if (state.sqrtPriceX96 === step.sqrtPriceNextX96) {\n      // if the tick is initialized, run the tick transition\n      if (step.initialized) {\n        let liquidityNet = BigInt(TickList.getTick(ticks, step.tickNext).liquidityNet)\n        // if we're moving leftward, we interpret liquidityNet as the opposite sign\n        // safe because liquidityNet cannot be type(int128).min\n        if (zeroForOne) liquidityNet *= NEGATIVE_ONE\n\n        state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet)\n      }\n\n      state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext\n    } else if (state.sqrtPriceX96 !== step.sqrtPriceStartX96) {\n      // updated comparison function\n      // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n      state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96)\n    }\n  }\n\n  return {\n    amountSpecifiedRemaining: state.amountSpecifiedRemaining,\n    amountCalculated: state.amountCalculated,\n    sqrtRatioX96: state.sqrtPriceX96,\n    liquidity: state.liquidity,\n    tickCurrent: state.tick,\n  }\n}\n","import type { Pool } from '@pancakeswap/routing-sdk'\n\nimport { V3_POOL_TYPE } from '../constants'\nimport { V3Pool } from '../types'\n\nexport function isV3Pool(p: Pool): p is V3Pool {\n  return p.type === V3_POOL_TYPE\n}\n"]}