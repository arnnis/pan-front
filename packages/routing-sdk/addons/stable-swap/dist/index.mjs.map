{"version":3,"sources":["../src/constants/poolType.ts","../src/constants/gasCost.ts","../src/transformer.ts","../src/createStablePool.ts","../../../../utils/tryParseAmount.ts","../../../../utils/viem/parseUnits.ts","../src/utils/isStablePool.ts"],"names":[],"mappings":"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","sourcesContent":["export const STABLE_POOL_TYPE = 'STABLE' as const\n","export const BASE_SWAP_COST_STABLE_SWAP = 180000n\n\nexport const COST_PER_EXTRA_HOP_STABLE_SWAP = 70000n\n","import { ChainId } from '@pancakeswap/chains'\nimport { Percent } from '@pancakeswap/swap-sdk-core'\nimport { parseCurrencyAmount, toSerializableCurrencyAmount } from '@pancakeswap/routing-sdk'\n\nimport { SerializableStablePool, StablePool, StablePoolData } from './types'\nimport { createStablePool } from './createStablePool'\n\nconst ONE_HUNDRED = 100n\n\nexport function toSerializableStablePool(stablePool: StablePool): SerializableStablePool {\n  const pool = stablePool.getPoolData()\n  return {\n    ...pool,\n    balances: pool.balances.map(toSerializableCurrencyAmount),\n    amplifier: pool.amplifier.toString(),\n    fee: pool.fee.toSignificant(6),\n  }\n}\n\nexport function parseStablePool(chainId: ChainId, pool: SerializableStablePool): StablePool {\n  const poolData: StablePoolData = {\n    ...pool,\n    balances: pool.balances.map((b) => parseCurrencyAmount(chainId, b)),\n    amplifier: BigInt(pool.amplifier),\n    fee: new Percent(parseFloat(pool.fee) * 1000000, ONE_HUNDRED * 1000000n),\n  }\n\n  return createStablePool(poolData)\n}\n","import { Price, Currency } from '@pancakeswap/swap-sdk-core'\nimport { getSwapOutput, getQuoteExactIn, getQuoteExactOut } from '@pancakeswap/stable-swap-sdk'\nimport tryParseAmount from '@pancakeswap/utils/tryParseAmount'\nimport invariant from 'tiny-invariant'\n\nimport type { StablePool, StablePoolData } from './types'\nimport { BASE_SWAP_COST_STABLE_SWAP, COST_PER_EXTRA_HOP_STABLE_SWAP, STABLE_POOL_TYPE } from './constants'\n\nexport function createStablePool(params: StablePoolData): StablePool {\n  let p = { ...params, type: STABLE_POOL_TYPE }\n\n  const pool: StablePool = {\n    type: STABLE_POOL_TYPE,\n    getReserve: (c) => {\n      const reserve = p.balances.find((b) => b.currency.wrapped.equals(c.wrapped))\n      invariant(reserve !== undefined, 'NO_RESERVE_FOUND')\n      return reserve\n    },\n    getCurrentPrice: (base, quote) => {\n      const { amplifier, balances, fee } = p\n      const baseIn = tryParseAmount('1', base)\n      if (!baseIn) {\n        throw new Error(`Cannot parse amount for ${base.symbol}`)\n      }\n      const quoteOut = getSwapOutput({\n        amplifier,\n        balances,\n        fee,\n        outputCurrency: quote,\n        amount: baseIn,\n      })\n\n      return new Price({\n        baseAmount: baseIn,\n        quoteAmount: quoteOut,\n      })\n    },\n    getTradingPairs: () => {\n      const pairs: [Currency, Currency][] = []\n      const size = p.balances.length\n      for (let i = 0; i < size - 1; i += 1) {\n        for (let j = i + 1; j < size; j += 1) {\n          pairs.push([p.balances[i].currency, p.balances[j].currency])\n        }\n      }\n      return pairs\n    },\n    getId: () => p.address,\n    update: (poolData) => {\n      p = { ...p, ...poolData }\n    },\n    log: () => `Stable Swap ${p.balances.map((b) => b.currency.symbol).join(' - ')} (${p.address}`,\n\n    getPoolData: () => p,\n\n    getQuote: ({ amount, isExactIn, quoteCurrency }) => {\n      const getQuote = isExactIn ? getQuoteExactIn : getQuoteExactOut\n      const { amplifier, balances, fee } = p\n      const [quote, { balances: newBalances }] = getQuote({\n        amount,\n        balances,\n        amplifier,\n        outputCurrency: quoteCurrency,\n        fee,\n      })\n      const newPoolData = { ...p, balances: newBalances }\n      return {\n        poolAfter: createStablePool(newPoolData),\n        quote,\n        pool,\n      }\n    },\n\n    estimateGasCostForQuote: () => {\n      return BASE_SWAP_COST_STABLE_SWAP + COST_PER_EXTRA_HOP_STABLE_SWAP\n    },\n  }\n\n  return pool\n}\n","import { Currency, CurrencyAmount } from '@pancakeswap/swap-sdk-core'\nimport { parseUnits } from './viem/parseUnits'\n\n// try to parse a user entered amount for a given token\nfunction tryParseAmount<T extends Currency>(value?: string, currency?: T | null): CurrencyAmount<T> | undefined {\n  if (!value || !currency) {\n    return undefined\n  }\n  try {\n    const typedValueParsed = parseUnits(value as `${number}`, currency.decimals).toString()\n\n    if (typedValueParsed !== '0') {\n      return CurrencyAmount.fromRawAmount(currency, BigInt(typedValueParsed))\n    }\n  } catch (error) {\n    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    console.debug(`Failed to parse input amount: \"${value}\"`, error)\n  }\n  // necessary for all paths to return a value\n  return undefined\n}\n\nexport default tryParseAmount\n","// Copy from viem package to avoid unnecessary dependency\nexport function parseUnits(value: string, decimals: number) {\n  let [integer, fraction = '0'] = value.split('.')\n\n  const negative = integer.startsWith('-')\n  if (negative) integer = integer.slice(1)\n\n  // trim leading zeros.\n  fraction = fraction.replace(/(0+)$/, '')\n\n  // round off if the fraction is larger than the number of decimals.\n  if (decimals === 0) {\n    if (Math.round(Number(`.${fraction}`)) === 1) integer = `${BigInt(integer) + 1n}`\n    fraction = ''\n  } else if (fraction.length > decimals) {\n    const [left, unit, right] = [\n      fraction.slice(0, decimals - 1),\n      fraction.slice(decimals - 1, decimals),\n      fraction.slice(decimals),\n    ]\n\n    const rounded = Math.round(Number(`${unit}.${right}`))\n    if (rounded > 9) fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, '0')\n    else fraction = `${left}${rounded}`\n\n    if (fraction.length > decimals) {\n      fraction = fraction.slice(1)\n      integer = `${BigInt(integer) + 1n}`\n    }\n\n    fraction = fraction.slice(0, decimals)\n  } else {\n    fraction = fraction.padEnd(decimals, '0')\n  }\n\n  return BigInt(`${negative ? '-' : ''}${integer}${fraction}`)\n}\n","import type { Pool } from '@pancakeswap/routing-sdk'\n\nimport { StablePool } from '../types'\nimport { STABLE_POOL_TYPE } from '../constants'\n\nexport function isStablePool(p: Pool): p is StablePool {\n  return p.type === STABLE_POOL_TYPE\n}\n"]}