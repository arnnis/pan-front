{"version":3,"sources":["../src/graph/vertice.ts","../src/graph/edge.ts","../src/graph/graph.ts","../src/graph/priceCalculator.ts","../../utils/formatFractions.ts","../src/findBestTrade.ts","../src/route.ts","../src/utils/groupPoolsByType.ts","../src/utils/getBetterTrade.ts","../src/stream.ts","../src/utils/logCurrency.ts","../src/utils/transformer.ts","../src/constants.ts","../src/utils/getPriceImpact.ts","../src/findKBestTrades.ts"],"names":["invariant","CurrencyAmount","Fraction","TradeType","Native","Percent","routes","getBestRoute","sum"],"mappings":"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","sourcesContent":["import { Currency, getCurrencyAddress } from '@pancakeswap/swap-sdk-core'\n\nimport { Vertice } from '../types'\n\nexport function getWrappedCurrencyKey(c: Currency) {\n  return `${c.chainId}-${getCurrencyAddress(c.wrapped)}`\n}\n\nexport function getVerticeKey(vertice: Vertice) {\n  return getWrappedCurrencyKey(vertice.currency)\n}\n","import type { Edge, Pool, Vertice } from '../types'\nimport { getVerticeKey } from './vertice'\n\nexport function getNeighbour(e: Edge, v: Vertice): Vertice {\n  return e.vertice0.currency.equals(v.currency) ? e.vertice1 : e.vertice0\n}\n\nexport function getEdgeKey(p: Pool, vertA: Vertice, vertB: Vertice): string {\n  const [vert0, vert1] = vertA.currency.sortsBefore(vertB.currency) ? [vertA, vertB] : [vertB, vertA]\n  return `${getVerticeKey(vert0)}-${getVerticeKey(vert1)}-${p.getId()}`\n}\n","import { Currency } from '@pancakeswap/swap-sdk-core'\nimport memoize from 'lodash/memoize.js'\nimport invariant from 'tiny-invariant'\n\nimport { Pool, Edge, Vertice, Graph } from '../types'\nimport { getEdgeKey, getNeighbour } from './edge'\nimport { getVerticeKey, getWrappedCurrencyKey } from './vertice'\n\ntype GraphParams = {\n  pools?: Pool[]\n\n  // If graph is provided, will clone it without creating new graph from pools\n  graph?: Graph\n}\n\nfunction cloneGraph(graph: Graph): Graph {\n  const pools = graph.edges.map((e) => e.pool)\n  return createGraph({ pools })\n}\n\nexport function createGraph({ pools, graph }: GraphParams): Graph {\n  if (graph) {\n    return cloneGraph(graph)\n  }\n\n  if (!pools) {\n    throw new Error('[Create graph]: Invalid pools')\n  }\n\n  const verticeMap = new Map<string, Vertice>()\n  const edgeMap = new Map<string, Edge>()\n\n  for (const p of pools) {\n    const pairs = p.getTradingPairs()\n    for (const [currency0, currency1] of pairs) {\n      const vertice0 = createVertice(currency0)\n      const vertice1 = createVertice(currency1)\n      const edge = createEdge(p, vertice0, vertice1)\n      if (!vertice0.edges.includes(edge)) vertice0.edges.push(edge)\n      if (!vertice1.edges.includes(edge)) vertice1.edges.push(edge)\n    }\n  }\n\n  function getVertice(c: Currency): Vertice | undefined {\n    return verticeMap.get(getWrappedCurrencyKey(c))\n  }\n\n  function getEdge(p: Pool, vert0: Vertice, vert1: Vertice): Edge | undefined {\n    return edgeMap.get(getEdgeKey(p, vert0, vert1))\n  }\n\n  function createVertice(c: Currency): Vertice {\n    const vert = getVertice(c)\n    if (vert) {\n      return vert\n    }\n    const vertice: Vertice = { currency: c.wrapped, edges: [] }\n    verticeMap.set(getWrappedCurrencyKey(c), vertice)\n    return vertice\n  }\n\n  function createEdge(p: Pool, vertice0: Vertice, vertice1: Vertice): Edge {\n    const edgeKey = getEdgeKey(p, vertice0, vertice1)\n    if (!edgeKey) {\n      throw new Error(`Create edge failed. Cannot get valid edge key for ${p}`)\n    }\n    const e = edgeMap.get(edgeKey)\n    if (e) {\n      return e\n    }\n    const edge: Edge = {\n      vertice0,\n      vertice1,\n      pool: p,\n    }\n    edgeMap.set(edgeKey, edge)\n    return edge\n  }\n\n  const hasValidRouteToVerticeWithinHops = memoize(\n    (vertice: Vertice, target: Vertice, hops: number, visitedVertices?: Set<Vertice>): boolean => {\n      if (vertice === target) {\n        return true\n      }\n      if (hops <= 0) {\n        return false\n      }\n      const visited = visitedVertices || new Set<Vertice>()\n      visited.add(vertice)\n      for (const edge of vertice.edges) {\n        const nextVertice = getNeighbour(edge, vertice)\n        if (nextVertice && !visited.has(nextVertice)) {\n          if (hasValidRouteToVerticeWithinHops(nextVertice, target, hops - 1, visited)) {\n            return true\n          }\n        }\n      }\n      return false\n    },\n    (v1, v2, hops) => `${getVerticeKey(v1)}-${getVerticeKey(v2)}-${hops}`,\n  )\n\n  return {\n    hasValidRouteToVerticeWithinHops,\n    vertices: Array.from(verticeMap.values()),\n    edges: Array.from(edgeMap.values()),\n    getVertice,\n    getEdge,\n\n    applySwap: async ({ isExactIn, route }) => {\n      function* loopPools() {\n        let i = isExactIn ? 0 : route.pools.length - 1\n        const getNext = () => (isExactIn ? i + 1 : i - 1)\n        const hasNext = isExactIn ? () => i < route.pools.length : () => i >= 0\n        for (; hasNext(); i = getNext()) {\n          yield i\n        }\n      }\n\n      const amount = isExactIn ? route.inputAmount : route.outputAmount\n      invariant(amount !== undefined, '[Apply swap]: Invalid base amount')\n      let quote = amount\n      let gasUseEstimate = 0n\n      for (const i of loopPools()) {\n        const vertA = getVertice(route.path[i])\n        const vertB = getVertice(route.path[i + 1])\n        const p = route.pools[i]\n        invariant(\n          vertA !== undefined && vertB !== undefined && p !== undefined,\n          '[Apply swap]: Invalid vertice and pool',\n        )\n        const edge = getEdge(p, vertA, vertB)\n        invariant(edge !== undefined, '[Apply swap]: No valid edge found')\n        const quoteCurrency = quote.currency.wrapped.equals(vertA.currency.wrapped) ? vertB.currency : vertA.currency\n        // eslint-disable-next-line no-await-in-loop\n        const quoteResult = edge.pool.getQuote({\n          amount: quote,\n          isExactIn,\n          quoteCurrency,\n        })\n        invariant(quoteResult !== undefined, '[Apply swap]: Failed to get quote')\n        edge.pool = quoteResult.poolAfter\n        quote = quoteResult.quote\n        gasUseEstimate += edge.pool.estimateGasCostForQuote(quoteResult)\n      }\n      return {\n        amount,\n        quote,\n        gasUseEstimate,\n      }\n    },\n  }\n}\n","import { type Token, CurrencyAmount, Price } from '@pancakeswap/swap-sdk-core'\nimport { Native } from '@pancakeswap/swap-sdk-evm'\nimport invariant from 'tiny-invariant'\n\nimport { Edge, Graph, Vertice } from '../types'\nimport { getNeighbour } from './edge'\n\ntype Params = {\n  graph: Graph\n  quote: Vertice\n  gasPriceWei: bigint\n}\n\nexport type PriceCalculator = ReturnType<typeof createPriceCalculator>\n\n// Get the price reference of all tokens in the graph against the specified vertice\nexport function createPriceCalculator({ graph, quote, gasPriceWei }: Params) {\n  const { chainId } = quote.currency\n  const priceMap = new Map<Vertice, Price<Token, Token>>()\n  const priceSources = new Map<Vertice, Edge[]>()\n  const processedVert = new Set<Vertice>()\n  const edgeWeight = new Map<Edge, bigint>()\n  let nextEdges: Edge[] = []\n  const getWeight = (e: Edge) => {\n    const weight = edgeWeight.get(e)\n    if (weight === undefined) {\n      throw new Error(`Invalid weight for edge ${e}`)\n    }\n    return weight\n  }\n\n  // anchor price\n  priceMap.set(quote, new Price(quote.currency, quote.currency, 1, 1))\n  nextEdges = getNextEdges(quote)\n  processedVert.add(quote)\n\n  while (nextEdges.length) {\n    const bestEdge = nextEdges.pop() as Edge\n    const [vFrom, vTo] = processedVert.has(bestEdge.vertice1)\n      ? [bestEdge.vertice1, bestEdge.vertice0]\n      : [bestEdge.vertice0, bestEdge.vertice1]\n    if (processedVert.has(vTo)) continue\n    const p = bestEdge.pool.getCurrentPrice(vTo.currency, vFrom.currency)\n    const vFromQuotePrice = getQuotePrice(vFrom)\n    invariant(vFromQuotePrice !== undefined, 'Invalid quote price')\n    priceMap.set(vTo, p.wrapped.multiply(vFromQuotePrice))\n    priceSources.set(vTo, [...(priceSources.get(vFrom) || []), bestEdge])\n    nextEdges = getNextEdges(vTo)\n    processedVert.add(vTo)\n    // console.log(\n    //   `Pricing: + Token ${vTo.currency.symbol} price=${getQuotePrice(vTo)?.toSignificant(6)}` +\n    //     ` from ${vFrom.currency.symbol} pool=${getPoolAddress(bestEdge.pool)} liquidity=${getWeight(bestEdge)}`,\n    // )\n  }\n\n  const wnative = Native.onChain(chainId).wrapped\n  const nativeVertice = graph.getVertice(wnative)\n  if (!nativeVertice) {\n    throw new Error('No valid native currency price found')\n  }\n  const nativePriceInQuote = getQuotePrice(nativeVertice)\n  const gasPriceInQuote = nativePriceInQuote?.quote(CurrencyAmount.fromRawAmount(wnative, gasPriceWei))\n  if (!gasPriceInQuote) {\n    throw new Error('Failed to get gas price in quote')\n  }\n\n  function getNextEdges(v: Vertice) {\n    const price = priceMap.get(v)\n    if (!price) {\n      throw new Error('Invalid price')\n    }\n    const newEdges = v.edges.filter((e) => {\n      if (processedVert.has(getNeighbour(e, v))) {\n        return false\n      }\n      const tokenReserve = e.pool.getReserve(v.currency)\n      invariant(tokenReserve !== undefined, 'Unexpected empty token reserve')\n      const liquidity = price.quote(tokenReserve.wrapped).quotient\n      edgeWeight.set(e, liquidity)\n      return true\n    })\n    newEdges.sort((e1, e2) => Number(getWeight(e1) - getWeight(e2)))\n    const res: Edge[] = []\n    while (nextEdges.length && newEdges.length) {\n      if (getWeight(nextEdges[0]) < getWeight(newEdges[0])) {\n        res.push(nextEdges.shift() as Edge)\n      } else {\n        res.push(newEdges.shift() as Edge)\n      }\n    }\n    return [...res, ...nextEdges, ...newEdges]\n  }\n\n  function getPrice(base: Vertice, targetQuote: Vertice): Price<Token, Token> | undefined {\n    const basePrice = getQuotePrice(base)\n    const quotePrice = getQuotePrice(targetQuote)\n    return basePrice && quotePrice ? basePrice.multiply(quotePrice.invert()) : undefined\n  }\n\n  function getQuotePrice(base: Vertice): Price<Token, Token> | undefined {\n    return priceMap.get(base)?.wrapped\n  }\n\n  function getGasPriceInBase(base: Vertice): CurrencyAmount<Token> | undefined {\n    const basePrice = getQuotePrice(base)\n    return gasPriceInQuote ? basePrice?.invert().quote(gasPriceInQuote) : undefined\n  }\n\n  function getPriceSources(v: Vertice) {\n    return priceSources.get(v) || []\n  }\n\n  return {\n    graph,\n    getGasPriceInBase,\n    getQuotePrice,\n    getPrice,\n    getPriceSources,\n  }\n}\n","import { Currency, CurrencyAmount, Fraction, Percent, Price, Rounding } from '@pancakeswap/swap-sdk-core'\n\nexport function formatPercent(percent?: Percent, precision?: number) {\n  return percent ? formatFraction(percent.asFraction.multiply(100), precision) : undefined\n}\n\nexport function formatFraction(\n  fraction?: Fraction | null | undefined,\n  precision: number | undefined = 6,\n  rounding: Rounding | undefined = undefined,\n) {\n  if (!fraction || fraction.denominator === 0n) {\n    return undefined\n  }\n  if (precision === 0 || fraction.greaterThan(10n ** BigInt(precision))) {\n    return fraction.toFixed(0)\n  }\n  return fraction.toSignificant(precision, undefined, rounding)\n}\n\nexport function formatPrice(price?: Price<Currency, Currency> | null | undefined, precision?: number | undefined) {\n  if (!price) {\n    return undefined\n  }\n  return formatFraction(price?.asFraction.multiply(price?.scalar), precision)\n}\n\nexport function formatAmount(amount?: CurrencyAmount<Currency> | null | undefined, precision?: number | undefined) {\n  if (!amount) {\n    return undefined\n  }\n  return formatFraction(\n    amount?.asFraction.divide(10n ** BigInt(amount?.currency.decimals)),\n    precision,\n    Rounding.ROUND_DOWN,\n  )\n}\n\nexport function parseNumberToFraction(num: number, precision = 6) {\n  if (Number.isNaN(num) || !Number.isFinite(num)) {\n    return undefined\n  }\n  const scalar = 10 ** precision\n  const scaledNum = num * scalar\n\n  if (Number.isNaN(scaledNum) || !Number.isFinite(scaledNum)) {\n    return undefined\n  }\n\n  return new Fraction(BigInt(Math.floor(scaledNum)), BigInt(scalar))\n}\n","import { formatFraction } from '@pancakeswap/utils/formatFractions'\nimport { Token, Currency, CurrencyAmount, Fraction, TradeType } from '@pancakeswap/swap-sdk-core'\nimport invariant from 'tiny-invariant'\n\nimport { PriceCalculator, createGraph, createPriceCalculator, getNeighbour } from './graph'\nimport { Edge, Graph, Pool, Route, TradeConfig, TradeWithGraph, Vertice } from './types'\nimport { isSameRoute, mergeRoute } from './route'\nimport { groupPoolsByType } from './utils/groupPoolsByType'\nimport { getBetterTrade } from './utils/getBetterTrade'\nimport { DEFAULT_STREAM, getBestStreamsConfig } from './stream'\n\nexport type FindBestTradeByStreamsParams = TradeConfig & {\n  amount: CurrencyAmount<Currency>\n  quoteCurrency: Currency\n\n  tradeType: TradeType\n\n  // If number is provided then will treat as number of streams, e.g. 3\n  // If array is provided then will treat as stream distribution, e.g. [1, 1, 1]\n  streams: number[] | number\n\n  // If graph is provided, will use it directly without creating new graph from candidatePools\n  graph?: Graph\n}\n\nexport type FindBestTradeParams = Omit<FindBestTradeByStreamsParams, 'streams'>\n\nexport async function findBestTrade({\n  maxSplits,\n  ...params\n}: FindBestTradeParams): Promise<TradeWithGraph<TradeType> | undefined> {\n  // NOTE: there's no max split cap right now. This option is only used to control the on/off of multiple splits\n  const splitDisabled = maxSplits !== undefined && maxSplits === 0\n\n  let bestTrade: TradeWithGraph<TradeType> | undefined\n  try {\n    bestTrade = await findBestTradeByStreams({\n      ...params,\n      streams: 1,\n    })\n  } catch (e) {\n    if (splitDisabled) {\n      throw e\n    }\n    bestTrade = await findBestTradeByStreams({\n      ...params,\n      streams: DEFAULT_STREAM,\n    })\n  }\n\n  if (splitDisabled) {\n    return bestTrade\n  }\n  const streams = getBestStreamsConfig(bestTrade)\n  if (streams === 1) {\n    return bestTrade\n  }\n  const bestTradeWithStreams = await findBestTradeByStreams({\n    ...params,\n    streams,\n  })\n\n  return getBetterTrade(bestTrade, bestTradeWithStreams)\n}\n\nexport async function findBestTradeByStreams(\n  params: FindBestTradeByStreamsParams,\n): Promise<TradeWithGraph<TradeType> | undefined> {\n  const { tradeType, candidatePools, ...rest } = params\n  const isExactIn = tradeType === TradeType.EXACT_INPUT\n  if (isExactIn) {\n    return getBestTrade(params)\n  }\n\n  // Exact output doesn't support mixed route\n  const poolsByType = groupPoolsByType(candidatePools)\n  const trades = await Promise.allSettled(\n    poolsByType.map((pools) => getBestTrade({ tradeType, candidatePools: pools, ...rest })),\n  )\n  let bestTrade: TradeWithGraph<TradeType> | undefined\n  for (const result of trades) {\n    if (result.status === 'rejected' || !result.value) {\n      continue\n    }\n    const { value: trade } = result\n    if (!bestTrade) {\n      bestTrade = trade\n      continue\n    }\n    bestTrade = getBetterTrade(bestTrade, trade)\n  }\n  return bestTrade\n}\n\nasync function getBestTrade({\n  amount: totalAmount,\n  candidatePools,\n  quoteCurrency,\n  gasPriceWei,\n  streams,\n  graph: graphOverride,\n  tradeType,\n  maxHops = 10,\n}: FindBestTradeByStreamsParams): Promise<TradeWithGraph<TradeType> | undefined> {\n  const isExactIn = tradeType === TradeType.EXACT_INPUT\n  const baseCurrency = totalAmount.currency\n  const inputCurrency = isExactIn ? baseCurrency : quoteCurrency\n  const outputCurrency = isExactIn ? quoteCurrency : baseCurrency\n  const graph = graphOverride || createGraph({ pools: candidatePools })\n  const amounts = getStreamedAmounts(totalAmount, streams)\n\n  const gasPrice = BigInt(typeof gasPriceWei === 'function' ? await gasPriceWei() : gasPriceWei)\n\n  // 1. Set static prices for each vertices\n  const start = graph.getVertice(baseCurrency)\n  const finish = graph.getVertice(quoteCurrency)\n  if (!start || !finish) {\n    throw new Error(`Invalid start vertice or finish vertice. Start ${start}, finish ${finish}`)\n  }\n  const priceCalculator = createPriceCalculator({\n    quote: start,\n    gasPriceWei: gasPrice,\n    graph,\n  })\n  const adjustQuoteByGas = (quote: CurrencyAmount<Currency>, gasCostInQuote: CurrencyAmount<Currency>) =>\n    isExactIn ? quote.subtract(gasCostInQuote) : quote.add(gasCostInQuote)\n  const isQuoteBetter = (quote: CurrencyAmount<Currency>, compareTo: CurrencyAmount<Currency>) =>\n    isExactIn ? quote.greaterThan(compareTo) : quote.lessThan(compareTo)\n  const getInputAmount = (amount: CurrencyAmount<Currency>, quote: CurrencyAmount<Currency>) =>\n    isExactIn ? amount : quote\n  const getOutputAmount = (amount: CurrencyAmount<Currency>, quote: CurrencyAmount<Currency>) =>\n    isExactIn ? quote : amount\n  const getQuoteAmount = (r: Route) => (isExactIn ? r.outputAmount : r.inputAmount)\n\n  const buildTrade = (g: Graph, routes: Route[]): TradeWithGraph<TradeType> => {\n    const {\n      gasEstimate,\n      quoteAmount,\n      gasCostInQuote,\n      gasCostInBase,\n      inputAmountWithGasAdjusted,\n      outputAmountWithGasAdjusted,\n    } = routes.reduce<{\n      gasEstimate: bigint\n      quoteAmount: CurrencyAmount<Currency>\n      gasCostInBase: CurrencyAmount<Currency>\n      gasCostInQuote: CurrencyAmount<Currency>\n      inputAmountWithGasAdjusted: CurrencyAmount<Currency>\n      outputAmountWithGasAdjusted: CurrencyAmount<Currency>\n    }>(\n      (result, r) => {\n        return {\n          gasEstimate: result.gasEstimate + r.gasUseEstimate,\n          quoteAmount: result.quoteAmount.add(getQuoteAmount(r)),\n          gasCostInBase: result.gasCostInBase.add(r.gasUseEstimateBase),\n          gasCostInQuote: result.gasCostInQuote.add(r.gasUseEstimateQuote),\n          inputAmountWithGasAdjusted: result.inputAmountWithGasAdjusted.add(r.inputAmountWithGasAdjusted),\n          outputAmountWithGasAdjusted: result.outputAmountWithGasAdjusted.add(r.outputAmountWithGasAdjusted),\n        }\n      },\n      {\n        gasEstimate: 0n,\n        quoteAmount: CurrencyAmount.fromRawAmount(quoteCurrency, 0),\n        gasCostInBase: CurrencyAmount.fromRawAmount(baseCurrency, 0),\n        gasCostInQuote: CurrencyAmount.fromRawAmount(quoteCurrency, 0),\n        inputAmountWithGasAdjusted: CurrencyAmount.fromRawAmount(inputCurrency, 0),\n        outputAmountWithGasAdjusted: CurrencyAmount.fromRawAmount(outputCurrency, 0),\n      },\n    )\n\n    return {\n      gasUseEstimateBase: gasCostInBase,\n      gasUseEstimateQuote: gasCostInQuote,\n      inputAmountWithGasAdjusted,\n      outputAmountWithGasAdjusted,\n      gasUseEstimate: gasEstimate,\n      inputAmount: getInputAmount(totalAmount, quoteAmount),\n      outputAmount: getOutputAmount(totalAmount, quoteAmount),\n      tradeType,\n      graph: g,\n      routes,\n    }\n  }\n\n  // 2. Find best route using Dijkstra's algo\n  async function findBestRoute(amount: CurrencyAmount<Currency>): Promise<Omit<Route, 'percent'> | undefined> {\n    invariant(start !== undefined && finish !== undefined, 'Invalid start/finish vertice')\n    const bestResult = new Map<\n      Vertice,\n      {\n        hops: number\n        gasSpent?: bigint\n        bestAmount: CurrencyAmount<Token>\n        bestQuote?: CurrencyAmount<Token>\n        bestSource?: Edge\n      }\n    >()\n    const processedVert = new Set<Vertice>()\n    bestResult.set(start, {\n      hops: 0,\n      bestAmount: amount.wrapped,\n      gasSpent: 0n,\n    })\n    const nextVertList: Vertice[] = [start]\n    const getHops = (vert: Vertice) => bestResult.get(vert)?.hops || 0\n    const getBestAmount = (vert: Vertice) => bestResult.get(vert)?.bestAmount\n    const getBestQuote = (vert: Vertice) => bestResult.get(vert)?.bestQuote\n    const getBestSource = (vert: Vertice) => bestResult.get(vert)?.bestSource\n    const getGasSpent = (vert: Vertice) => bestResult.get(vert)?.gasSpent || 0n\n    const getNextVert = () => {\n      let vert: Vertice | undefined\n      let bestQuote: CurrencyAmount<Token> | undefined\n      let bestVertIndex: number | undefined\n      for (const [i, vertice] of nextVertList.entries()) {\n        const currentBestQuote = getBestQuote(vertice)\n        if (\n          vert === undefined ||\n          bestQuote === undefined ||\n          (currentBestQuote && isQuoteBetter(currentBestQuote, bestQuote))\n        ) {\n          vert = vertice\n          bestQuote = currentBestQuote\n          bestVertIndex = i\n        }\n      }\n      return { vert, index: bestVertIndex }\n    }\n    const getBestRoute = (vert: Vertice) => {\n      const pools: Pool[] = []\n      const path: Currency[] = [quoteCurrency]\n      for (let v: Vertice | undefined = finish; getBestSource(v); v = getNeighbour(getBestSource(v)!, v)) {\n        const bestSource = getBestSource(v)\n        invariant(bestSource !== undefined, 'Invalid best source')\n        const neighbour = getNeighbour(bestSource, v)\n        const nextCurrency = neighbour === start ? baseCurrency : neighbour.currency\n        if (isExactIn) {\n          pools.unshift(bestSource.pool)\n          path.unshift(nextCurrency)\n        } else {\n          pools.push(bestSource.pool)\n          path.push(nextCurrency)\n        }\n      }\n\n      // DEBUG\n      // console.log(\n      //   '[DEBUG ROUTE]: ',\n      //   path\n      //     .map((t) => {\n      //       const v = graph.getVertice(t)\n      //       const amount = v && getBestAmount(v)\n      //       return `${amount?.toExact()} ${amount?.currency.symbol}`\n      //     })\n      //     .join(' -> '),\n      // )\n\n      const gasCost = getGasSpent(vert)\n      const quoteAmountRaw = getBestAmount(vert)\n      invariant(quoteAmountRaw !== undefined, 'Invalid quote amount')\n      const quoteAmount = CurrencyAmount.fromRawAmount(quoteCurrency, quoteAmountRaw.quotient)\n      const gasCostInBase = getGasCostInCurrency({\n        priceCalculator,\n        gasCost,\n        currency: baseCurrency,\n      })\n      const gasCostInQuote = getGasCostInCurrency({\n        priceCalculator,\n        gasCost,\n        currency: quoteCurrency,\n      })\n      const quoteAmountWithGasAdjusted = CurrencyAmount.fromRawAmount(\n        quoteCurrency,\n        gasCostInQuote ? adjustQuoteByGas(quoteAmount, gasCostInQuote).quotient : 0,\n      )\n\n      return {\n        path,\n        pools,\n        gasUseEstimate: gasCost,\n        inputAmount: getInputAmount(amount, quoteAmount),\n        outputAmount: getOutputAmount(amount, quoteAmount),\n        inputAmountWithGasAdjusted: getInputAmount(amount, quoteAmountWithGasAdjusted),\n        outputAmountWithGasAdjusted: getOutputAmount(amount, quoteAmountWithGasAdjusted),\n        gasUseEstimateQuote: gasCostInQuote,\n        gasUseEstimateBase: gasCostInBase,\n      }\n    }\n\n    for (;;) {\n      const { vert, index } = getNextVert()\n      if (!vert || index === undefined) return undefined\n\n      // console.log('Next vert ->', vert.currency.symbol);\n\n      if (vert === finish) {\n        return getBestRoute(vert)\n      }\n      nextVertList.splice(index, 1)\n\n      const currentHop = getHops(vert)\n      for (const e of vert.edges) {\n        const prevBestSource = getBestSource(vert)\n\n        // Exact output doesn't support mixed route\n        if (!isExactIn && prevBestSource && e.pool.type !== prevBestSource.pool.type) {\n          continue\n        }\n\n        const v2 = vert === e.vertice0 ? e.vertice1 : e.vertice0\n        if (processedVert.has(v2)) continue\n\n        if (!graph.hasValidRouteToVerticeWithinHops(v2, finish, maxHops - currentHop - 1)) {\n          continue\n        }\n\n        try {\n          const bestAmount = getBestAmount(vert)\n          invariant(bestAmount !== undefined, 'Invalid amount')\n          // eslint-disable-next-line no-await-in-loop\n          const quoteResult = e.pool.getQuote({\n            amount: bestAmount,\n            isExactIn,\n            quoteCurrency: e.vertice0.currency.equals(bestAmount.currency.wrapped)\n              ? e.vertice1.currency\n              : e.vertice0.currency,\n          })\n          // console.log(`Get quote success ${quoteResult?.quote.toExact()}`)\n          invariant(quoteResult !== undefined, 'Invalid quote result')\n          const { quote } = quoteResult\n          const gasPriceInV2 = priceCalculator.getGasPriceInBase(v2)\n          invariant(gasPriceInV2 !== undefined, 'Invalid gas price in v2')\n          const gasSpent = e.pool.estimateGasCostForQuote(quoteResult) + getGasSpent(vert)\n\n          const price = priceCalculator.getPrice(v2, finish)\n          invariant(\n            price !== undefined,\n            `Failed to get price, base ${v2.currency.symbol}, quote ${finish.currency.symbol}`,\n          )\n          const gasSpentInQuote = price.quote(gasPriceInV2.multiply(gasSpent))\n          const newQuote = adjustQuoteByGas(price.quote(quote.wrapped), gasSpentInQuote)\n          // const newQuote = price.quote(quote);\n          const bestSource = getBestSource(v2)\n          const v2BestQuote = getBestQuote(v2)\n\n          // console.log(\n          //   v2.currency.symbol,\n          //   e.pool.log(),\n          //   newQuote.toExact(),\n          //   newQuote.currency.symbol,\n          // );\n          if (!bestSource) nextVertList.push(v2)\n          if (!bestSource || !v2BestQuote || isQuoteBetter(newQuote, v2BestQuote)) {\n            bestResult.set(v2, {\n              hops: currentHop + 1,\n              gasSpent,\n              bestAmount: quote.wrapped,\n              bestSource: e,\n              bestQuote: newQuote.wrapped,\n            })\n          }\n        } catch (_err) {\n          // console.error(\n          //   `[GetQuote]: Failed to get quote from ${vert.currency.symbol} to ${v2.currency.symbol}`,\n          //   e.pool,\n          //   _err,\n          // )\n          // console.error(_err)\n          continue\n        }\n      }\n      processedVert.add(vert)\n    }\n  }\n\n  let routeMerged = false\n  const routes: Route[] = []\n  for (const { amount, percent } of amounts) {\n    // eslint-disable-next-line no-await-in-loop\n    const route = await findBestRoute(amount)\n    invariant(\n      route !== undefined,\n      `No valid route found for base amount ${amount.toExact()} ${amount.currency.symbol} and quote currency ${\n        quoteCurrency.symbol\n      }`,\n    )\n    // eslint-disable-next-line no-await-in-loop\n    await graph.applySwap({ route, isExactIn })\n    const newRoute = {\n      ...route,\n      percent,\n    }\n    const index = routes.findIndex((r) => isSameRoute(r, newRoute))\n    if (index < 0) {\n      routes.push(newRoute)\n    } else {\n      routes[index] = mergeRoute(routes[index], newRoute)\n      routeMerged = true\n    }\n  }\n  // No valid route found\n  if (!routes.length) {\n    return undefined\n  }\n\n  if (!routeMerged) {\n    return buildTrade(graph, routes)\n  }\n\n  // Rebuild graph if route is merged and estimate actual quote and gas cost\n  const finalGraph = createGraph({\n    graph: graphOverride,\n    pools: candidatePools,\n  })\n  const s = finalGraph.getVertice(baseCurrency)\n  invariant(s !== undefined, '[Graph rebuild]: Invalid start vertice')\n  const pc = createPriceCalculator({\n    quote: s,\n    gasPriceWei: gasPrice,\n    graph: finalGraph,\n  })\n  const finalRoutes: Route[] = []\n  for (const r of routes) {\n    // eslint-disable-next-line no-await-in-loop\n    const { amount, quote: quoteRaw, gasUseEstimate } = await finalGraph.applySwap({ isExactIn, route: r })\n    const quote = CurrencyAmount.fromRawAmount(quoteCurrency, quoteRaw.quotient)\n    const gasCostInBase = getGasCostInCurrency({\n      priceCalculator: pc,\n      gasCost: gasUseEstimate,\n      currency: baseCurrency,\n    })\n    const gasCostInQuote = getGasCostInCurrency({\n      priceCalculator: pc,\n      gasCost: gasUseEstimate,\n      currency: quoteCurrency,\n    })\n    const quoteAmountWithGasAdjusted = CurrencyAmount.fromRawAmount(\n      quoteCurrency,\n      gasCostInQuote ? adjustQuoteByGas(quote, gasCostInQuote).quotient : 0,\n    )\n    finalRoutes.push({\n      ...r,\n      gasUseEstimate,\n      inputAmount: getInputAmount(amount, quote),\n      outputAmount: getOutputAmount(amount, quote),\n      inputAmountWithGasAdjusted: getInputAmount(amount, quoteAmountWithGasAdjusted),\n      outputAmountWithGasAdjusted: getOutputAmount(amount, quoteAmountWithGasAdjusted),\n      gasUseEstimateQuote: gasCostInQuote,\n      gasUseEstimateBase: gasCostInBase,\n    })\n  }\n  return buildTrade(finalGraph, finalRoutes)\n}\n\nfunction getStreamedAmounts(\n  amount: CurrencyAmount<Currency>,\n  streams: number[] | number,\n): { amount: CurrencyAmount<Currency>; percent: number }[] {\n  const streamSum = Array.isArray(streams) ? streams.reduce((sum, s) => sum + s, 0) : streams\n  const streamDistributions = Array.isArray(streams)\n    ? streams.map((stream) => new Fraction(stream, streamSum))\n    : Array.from({ length: streams }).map(() => new Fraction(1, streamSum))\n  const numOfStreams = streamDistributions.length\n\n  let sum = new Fraction(0)\n  const amounts: { amount: CurrencyAmount<Currency>; percent: number }[] = []\n  for (const [index, stream] of streamDistributions.entries()) {\n    const streamAmount = index === numOfStreams - 1 ? amount.subtract(amount.multiply(sum)) : amount.multiply(stream)\n    const revisedStream = index === numOfStreams - 1 ? new Fraction(1).subtract(sum) : stream\n    const percent = Number(formatFraction(revisedStream) || 0) * 100\n    amounts.push({ amount: streamAmount, percent })\n    sum = sum.add(stream)\n  }\n  return amounts\n}\n\nfunction getGasCostInCurrency({\n  priceCalculator,\n  gasCost,\n  currency,\n}: {\n  priceCalculator: PriceCalculator\n  gasCost: bigint\n  currency: Currency\n}) {\n  const v = priceCalculator.graph.getVertice(currency)\n  const gasPriceInCurrency = v && priceCalculator.getGasPriceInBase(v)\n  const gasCostInCurrencyRaw = gasPriceInCurrency?.multiply(gasCost)\n  return CurrencyAmount.fromRawAmount(currency, gasCostInCurrencyRaw?.quotient || 0)\n}\n","import { Route } from './types'\n\nexport function isSameRoute(one: Route, another: Route) {\n  if (one.pools.length !== another.pools.length) {\n    return false\n  }\n  for (const [index, p] of one.pools.entries()) {\n    if (p.type !== another.pools[index].type) {\n      return false\n    }\n    if (p.getId() !== another.pools[index].getId()) {\n      return false\n    }\n  }\n  return true\n}\n\n// Must to be the same route\nexport function mergeRoute(one: Route, another: Route): Route {\n  return {\n    ...one,\n    inputAmount: one.inputAmount.add(another.inputAmount),\n    outputAmount: one.outputAmount.add(another.outputAmount),\n    gasUseEstimateBase: another.gasUseEstimateBase\n      ? one.gasUseEstimateBase.add(another.gasUseEstimateBase)\n      : one.gasUseEstimateBase,\n    gasUseEstimateQuote: another.gasUseEstimateQuote\n      ? one.gasUseEstimateQuote.add(another.gasUseEstimateQuote)\n      : one.gasUseEstimateQuote,\n    gasUseEstimate: one.gasUseEstimate + another.gasUseEstimate,\n    inputAmountWithGasAdjusted: another.inputAmountWithGasAdjusted\n      ? one.inputAmountWithGasAdjusted?.add(another.inputAmountWithGasAdjusted)\n      : one.inputAmountWithGasAdjusted,\n    outputAmountWithGasAdjusted: another.outputAmountWithGasAdjusted\n      ? one.outputAmountWithGasAdjusted?.add(another.outputAmountWithGasAdjusted)\n      : one.outputAmountWithGasAdjusted,\n    percent: one.percent + another.percent,\n  }\n}\n","import { Pool } from '../types'\n\nexport function groupPoolsByType(pools: Pool[]): Pool[][] {\n  const poolsByType = new Map<any, Pool[]>()\n  for (const pool of pools) {\n    poolsByType.set(pool.type, [...(poolsByType.get(pool.type) || []), pool])\n  }\n  return Array.from(poolsByType.values())\n}\n","import { TradeType } from '@pancakeswap/swap-sdk-core'\n\nimport { Trade } from '../types'\n\n// Is trade A better than trade B\nexport function isTradeBetter<T extends Trade<TradeType>>(tradeA: T, tradeB: T): boolean {\n  const isExactIn = tradeA.tradeType === TradeType.EXACT_INPUT\n  if (isExactIn) {\n    return tradeA.outputAmountWithGasAdjusted.greaterThan(tradeB.outputAmountWithGasAdjusted)\n  }\n  return tradeA.inputAmountWithGasAdjusted.lessThan(tradeB.inputAmountWithGasAdjusted)\n}\n\nexport function getBetterTrade<T extends Trade<TradeType>>(tradeA?: T, tradeB?: T): T | undefined {\n  if (!tradeA && !tradeB) return undefined\n  if (!tradeA && tradeB) return tradeB\n  if (tradeA && !tradeB) return tradeA\n\n  if (isTradeBetter<T>(tradeB!, tradeA!)) {\n    return tradeB\n  }\n  return tradeA\n}\n","import { TradeType } from '@pancakeswap/swap-sdk-core'\nimport { formatFraction } from '@pancakeswap/utils/formatFractions'\n\nimport { Trade } from './types'\nimport { getPriceImpact } from './utils'\n\nexport const DEFAULT_STREAM = 10\n\nexport function getBestStreamsConfig(trade?: Trade<TradeType>) {\n  const maxStreams = 100\n  if (!trade) {\n    return DEFAULT_STREAM\n  }\n  const priceImpact = getPriceImpact(trade)\n  if (!priceImpact) {\n    return DEFAULT_STREAM\n  }\n  const { gasUseEstimateBase, inputAmount, outputAmount } = trade\n  if (!gasUseEstimateBase) {\n    return DEFAULT_STREAM\n  }\n  const amount = trade.tradeType === TradeType.EXACT_INPUT ? inputAmount : outputAmount\n\n  const bestFlowAmount = Math.sqrt(\n    (Number(gasUseEstimateBase.toExact()) * Number(amount.toExact())) / Number(formatFraction(priceImpact.asFraction)),\n  )\n  const streams = Math.round(Number(amount.toExact()) / bestFlowAmount)\n  if (!Number.isFinite(streams)) {\n    return DEFAULT_STREAM\n  }\n  return Math.max(1, Math.min(streams, maxStreams))\n}\n","import { Currency } from '@pancakeswap/swap-sdk-core'\n\nexport function logCurrency(c: Currency) {\n  return `${c.chainId}_${c.isNative}_${c.wrapped.address}`\n}\n","import { ChainId } from '@pancakeswap/chains'\nimport { Currency, CurrencyAmount, TradeType } from '@pancakeswap/swap-sdk-core'\nimport { Native, ERC20Token } from '@pancakeswap/swap-sdk-evm'\n\nimport {\n  SerializableCurrency,\n  SerializableCurrencyAmount,\n  Pool,\n  Route,\n  SerializablePool,\n  SerializableRoute,\n  Trade,\n  SerializableTrade,\n} from '../types'\nimport { ADDRESS_ZERO } from '../constants'\n\nexport type SerializableConfig<P extends Pool = Pool, SP extends SerializablePool = SerializablePool> = {\n  toSerializablePool: (pool: P) => SP\n}\n\nexport type ParseConfig<P extends Pool = Pool, SP extends SerializablePool = SerializablePool> = {\n  parsePool: (chainId: ChainId, pool: SP) => P\n}\n\nexport function toSerializableCurrency(currency: Currency): SerializableCurrency {\n  return {\n    address: currency.isNative ? ADDRESS_ZERO : currency.wrapped.address,\n    decimals: currency.decimals,\n    symbol: currency.symbol,\n  }\n}\n\nexport function toSerializableCurrencyAmount(amount: CurrencyAmount<Currency>): SerializableCurrencyAmount {\n  return {\n    currency: toSerializableCurrency(amount.currency),\n    value: amount.quotient.toString(),\n  }\n}\n\nexport function toSerializableRoute<P extends Pool = Pool, SP extends SerializablePool = SerializablePool>(\n  route: Route<P>,\n  { toSerializablePool }: SerializableConfig<P, SP>,\n): SerializableRoute {\n  return {\n    ...route,\n    pools: route.pools.map(toSerializablePool),\n    path: route.path.map(toSerializableCurrency),\n    inputAmount: toSerializableCurrencyAmount(route.inputAmount),\n    outputAmount: toSerializableCurrencyAmount(route.outputAmount),\n    gasUseEstimate: String(route.gasUseEstimate),\n    gasUseEstimateBase: toSerializableCurrencyAmount(route.gasUseEstimateBase),\n    gasUseEstimateQuote: toSerializableCurrencyAmount(route.gasUseEstimateQuote),\n    inputAmountWithGasAdjusted: toSerializableCurrencyAmount(route.inputAmountWithGasAdjusted),\n    outputAmountWithGasAdjusted: toSerializableCurrencyAmount(route.outputAmountWithGasAdjusted),\n  }\n}\n\nexport function toSerializableTrade<P extends Pool = Pool, SP extends SerializablePool = SerializablePool>(\n  trade: Trade<TradeType, P>,\n  config: SerializableConfig<P, SP>,\n): SerializableTrade {\n  return {\n    ...trade,\n    inputAmount: toSerializableCurrencyAmount(trade.inputAmount),\n    outputAmount: toSerializableCurrencyAmount(trade.outputAmount),\n    routes: trade.routes.map((route) => toSerializableRoute(route, config)),\n    gasUseEstimate: String(trade.gasUseEstimate),\n    gasUseEstimateBase: toSerializableCurrencyAmount(trade.gasUseEstimateBase),\n    gasUseEstimateQuote: toSerializableCurrencyAmount(trade.gasUseEstimateQuote),\n    inputAmountWithGasAdjusted: toSerializableCurrencyAmount(trade.inputAmountWithGasAdjusted),\n    outputAmountWithGasAdjusted: toSerializableCurrencyAmount(trade.outputAmountWithGasAdjusted),\n  }\n}\n\nexport function parseCurrency(chainId: ChainId, currency: SerializableCurrency): Currency {\n  if (currency.address === ADDRESS_ZERO) {\n    return Native.onChain(chainId)\n  }\n  const { address, decimals, symbol } = currency\n  return new ERC20Token(chainId, address, decimals, symbol)\n}\n\nexport function parseCurrencyAmount(chainId: ChainId, amount: SerializableCurrencyAmount): CurrencyAmount<Currency> {\n  return CurrencyAmount.fromRawAmount(parseCurrency(chainId, amount.currency), amount.value)\n}\n\nexport function parseRoute<P extends Pool = Pool, SP extends SerializablePool = SerializablePool>(\n  chainId: ChainId,\n  route: SerializableRoute,\n  { parsePool }: ParseConfig<P, SP>,\n): Route {\n  return {\n    ...route,\n    pools: route.pools.map((p) => parsePool(chainId, p)),\n    path: route.path.map((n) => parseCurrency(chainId, n)),\n    inputAmount: parseCurrencyAmount(chainId, route.inputAmount),\n    outputAmount: parseCurrencyAmount(chainId, route.outputAmount),\n    gasUseEstimate: BigInt(route.gasUseEstimate),\n    gasUseEstimateBase: parseCurrencyAmount(chainId, route.gasUseEstimateBase),\n    gasUseEstimateQuote: parseCurrencyAmount(chainId, route.gasUseEstimateQuote),\n    inputAmountWithGasAdjusted: parseCurrencyAmount(chainId, route.inputAmountWithGasAdjusted),\n    outputAmountWithGasAdjusted: parseCurrencyAmount(chainId, route.outputAmountWithGasAdjusted),\n  }\n}\n\nexport function parseTrade<P extends Pool = Pool, SP extends SerializablePool = SerializablePool>(\n  chainId: ChainId,\n  trade: SerializableTrade,\n  config: ParseConfig<P, SP>,\n): Trade<TradeType> {\n  return {\n    ...trade,\n    routes: trade.routes.map((r) => parseRoute<P, SP>(chainId, r, config)),\n    inputAmount: parseCurrencyAmount(chainId, trade.inputAmount),\n    outputAmount: parseCurrencyAmount(chainId, trade.outputAmount),\n    gasUseEstimate: BigInt(trade.gasUseEstimate),\n    gasUseEstimateBase: parseCurrencyAmount(chainId, trade.gasUseEstimateBase),\n    gasUseEstimateQuote: parseCurrencyAmount(chainId, trade.gasUseEstimateQuote),\n    inputAmountWithGasAdjusted: parseCurrencyAmount(chainId, trade.inputAmountWithGasAdjusted),\n    outputAmountWithGasAdjusted: parseCurrencyAmount(chainId, trade.outputAmountWithGasAdjusted),\n  }\n}\n","export const ADDRESS_ZERO = '0x0000000000000000000000000000000000000000'\n","import { CurrencyAmount, Percent, TradeType, Price, Currency } from '@pancakeswap/swap-sdk-core'\n\nimport { Trade, Route } from '../types'\n\nexport function getPriceImpact(\n  trade: Pick<Trade<TradeType>, 'outputAmount' | 'routes'> & {\n    routes: Pick<Route, 'path' | 'pools'>[]\n  },\n): Percent {\n  let spotOutputAmount = CurrencyAmount.fromRawAmount(trade.outputAmount.currency.wrapped, 0)\n  for (const route of trade.routes) {\n    const { inputAmount } = route\n    // FIXME typing\n    const midPrice: any = getMidPrice(route)\n    spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount.wrapped))\n  }\n  const priceImpact = spotOutputAmount.subtract(trade.outputAmount.wrapped).divide(spotOutputAmount)\n  return new Percent(priceImpact.numerator, priceImpact.denominator)\n}\n\nexport function getMidPrice({ path, pools }: Pick<Route, 'path' | 'pools'>) {\n  let i = 0\n  let price: Price<Currency, Currency> | null = null\n  for (const pool of pools) {\n    const input = path[i].wrapped\n    const output = path[i + 1].wrapped\n    const poolPrice = pool.getCurrentPrice(input, output)\n\n    price = price ? price.multiply(poolPrice) : poolPrice\n    i += 1\n  }\n\n  if (!price) {\n    throw new Error('Get mid price failed')\n  }\n  return price\n}\n","import { TradeType } from '@pancakeswap/swap-sdk-core'\nimport { findBestTrade, type FindBestTradeParams } from './findBestTrade'\nimport { TradeWithGraph } from './types'\nimport { isTradeBetter } from './utils'\n\nexport type FindKBestTradesParams = FindBestTradeParams & {\n  top: number\n}\n\nexport async function findKBestTrades({\n  top,\n  ...params\n}: FindKBestTradesParams): Promise<TradeWithGraph<TradeType>[] | undefined> {\n  const best = await findBestTrade(params)\n  if (!best) {\n    return undefined\n  }\n\n  const trades: TradeWithGraph<TradeType>[] = [best]\n  const potentialTrades: TradeWithGraph<TradeType>[] = []\n  const { candidatePools } = params\n\n  for (let i = 0; i < top - 1; i += 1) {\n    const { pools, path } = getBestRoute(trades[i])\n    for (let j = 0; j < path.length - 1; j += 1) {\n      const rootPath = j === 0 ? [] : pools.slice(0, j)\n      const edgeToRemove = new Set<string>()\n      const getPoolsToRoute = () => candidatePools.filter((p) => !edgeToRemove.has(p.getId()))\n      for (const trade of trades) {\n        const route = getBestRoute(trade)\n        if (\n          !rootPath.length ||\n          (route.pools[j] && rootPath.every((edge, index) => edge.getId() === route.pools[index]?.getId()))\n        ) {\n          edgeToRemove.add(route.pools[j].getId())\n        }\n      }\n      if (edgeToRemove.size === 0) {\n        continue\n      }\n\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        const trade = await findBestTrade({ ...params, candidatePools: getPoolsToRoute() })\n        if (trade) {\n          potentialTrades.push(trade)\n        }\n      } catch (e) {\n        console.error('Fail to find potential trade', e)\n      }\n    }\n\n    if (!potentialTrades.length) {\n      break\n    }\n    potentialTrades.sort((a, b) => (isTradeBetter(a, b) ? -1 : 1))\n    trades.push(potentialTrades.shift()!)\n  }\n\n  return trades\n}\n\nfunction getBestRoute({ routes }: Pick<TradeWithGraph<TradeType>, 'routes'>) {\n  return routes.sort((r1, r2) => r2.percent - r1.percent)[0]\n}\n"]}